{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview Each HyperUI application consists of three basic sets of files: Binary data (images, sounds, any custom files, etc.) Text based resource files that specify the entire structure of the user interface, as well as any other text-based data you may need The executable itself, which handles all logic, custom actions, custom rendering, etc. using the above two categories Installation Getting started on your first project is very simple. Please note that for C++ based projects, you need Visual Studio 2015 or newer on Windows, and the latest version of XCode on Mac OS. Hyper UI source and sample projects can be downloaded here: https://github.com/sadcatsoft/hyperui C++ /* - Download and unzip HyperUI to any location of your choice - On Windows, open the HyperUI/examples/blankAppTemplate/msvc2015 solution in Visual Studio - On Mac OS: * In the terminal, run buildLibs to compile the two dependencies, freetype and libpng * Open the HyperUI/examples/blankAppTemplate/macOS project in XCode */ Python pip install hyperui Your First Application To use HyperUI, it first needs to be initialized. In C++, you need to explicitly do so, while in Python it's done for you when you import the hyperui module: C++ HyperUI :: initialize ( Blank HyperUI App ); // We need to tell our application where the resources from the library // are. In this case, we store them in the subfolder hyperUI relative // to our main application folder. ResourceManager :: setStandardDataPathPrefix ( hyperUI ); Python import hyperui Now, we can create our main window and run the application: C++ // Run it! HyperUI :: run (); Python hyperui . run () When you compile and run the application (C++) or run the script (Python), you should see a blank window appear. Hooray! Adding a Button Well, a window is nice, but pretty useless. How do we make it do something and be actually useful? For that, we need to add some custom UI elements: In the root folder where your Python script or C++ source is located, create a subfolder called \"customUI\". This will server as a folder that contains our custom UI. In that subfolder, crate an empty file named resUI.txt - this will the main file which specifies our user interface elements. Open resUI.txt, and add the following text to it: #include ../hyperUI/config/resUICommon.h window id = mainWindow layer = main fillXLess = 0up fillYLess = 0up button id = testButton text = PRESS ME action = showMessage actionValue = The button has been pressed. Yay! width = 100up /button /window Now that we have created some UI specifications, we need to tell our app to actually use it: C++ // This struct holds optional parameters we can use to customize our window HyperUI :: SWindowParms rParms ; // Here, we tell HyperUI that the UI collection we want to use for our window is resUI.txt // and provide a relative path to it rParms . myInitCollectionType = ResourceManager :: getInstance () - addCollection ( customUI FOLDER_SEP resUI.txt , true ); // Modify the run() call to take these parameters HyperUI :: run ( rParms ); Python # Create a custom Window class that inherits from our base HyperUI window class PyWindow ( hyperui . Window ): def __init__ ( self , file_path , title = , w = - 1 , h = - 1 , first_layer = ): hyperui . Window . __init__ ( self , file_path , title , w , h , first_layer ) # Get the path to where we re running module_path = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ])) # Create a window and provide the full path to our UI specifications file wnd = hyperui . Window ( os . path . join ( module_path , elementsCatalogUI , resUI.txt )) # Tell HyperUI that we want to use our own window class: hyperui . run ( wnd ) Now re-run the application. You should see that the background of the window has changed to a dark texture, and that there is a button in the middle which, when pressed, shows a text box with the confirmation message. We've introduced a lot of new stuff, so let's go line-by-line and explain what's going on here. First, you'll notice that all of our UI and other resource files come in an XML-like (but better :) format, designed first and foremost for readability. Here are some notes on it: The indentation does not matter. Elements are opened using tag tags, and closed using the corresponding /tag . These can be nested. Data is specified using format: propertyName = property value The type of the property is determined automatically. The property must fit on one line. Special syntax exists for specifying longer text segments: text = ___[[[ This is a long piece of text that may be broken up over any number of lines. ]]]___ Properties currently cannot be arbitrary and must be previously declared using DECLARE_PROPERTY() macro in C++ - or be one of existing properties. This is done for performance reasons. We support #ifdef/#endif and #include directives, as well as single-class inheritance. See Advanced section for specifics on these. Analysis Now, what do all those lines mean? Let's start with the first one: #include ../hyperUI/config/resUICommon.h HyperUI is built on the idea that there should be no magic, black-box behaviour - everything should be traceable and logical. The above statement includes the main UI configuration file that specifies default values for elements with tags window and button , and is located using the standard path relative to the location of the file it's included from. You can open it up and see for yourself. id = mainWindow layer = main Each element must have a globally-unique id - which is what the id property specifies in this case. Also, each top-level UI element must have a layer property to be useful - in HyperUI, we show user interface elements not based on telling the program to show a specific window or element, but on showing layers of elements. This means several disjoint elements can be shown all at once with a single command. Here, we specify that the window element in question belongs to the layer named \"main\". Generally, layer names are just custom strings - you can use anything. The \"main\" layer is the exception - by default, these elements will be shown on start up. You can override this behaviour by specifying your own layer name to show when the application launches. fillXLess = 0up fillYLess = 0up What do these mean? And what is this \"up\" thing? \"up\" stands for \"universal pixel\", and is used as a unit of measurement on the screen which scales with the screen density on the specific device the app is running on. This means you can use a single UI configuration for all devices (but don't worry, you can also override it on specific screen densities). The fillXLess property tells HyperUI to stretch this element to fill the main window or its parent element if it has one - less the padding on each side specified by the value of this property. In this case, we want the element to completely fill the window, so the values are set to 0. However, if you set them to 20up and re-run the app, you'll notice that on regular-density screens, there will now be a padding on each side of 20 pixels. action = showMessage actionValue = The button has been pressed. Yay! Clickable elements such as buttons, menus, checkboxes, etc. all can have an action associated with them, as well as parameters that action needs. Some actions are built-in for convenience (\"showMessage\", \"showLayer\", \"hideLayer\", etc.), but you can also add any custom action you want. In this case, we specify that when the button is clicked, we want to show a message and provide its text in the actionValue property. Inheritance HyperUI resource files support an equavalent to classes and single-class inheritance. The items you have seen in the examples above can all be thought as instances of previously-declared classes. A class, or definition, of an element, is defined as follwoing: customElem definition text = Base text x = 20up anotherElem id = defChildElem text = Child text /anotherElem /customElem customElem id = elemInstance text = Overriding text anotherElem id = defChildElem text = Overriding child text /anotherElem /customElem Here, the first item is the definition of the customElem type. All items that use the same tag after that point in the file will inherit all of the properties of the defintion, as well as all of its children. Also note that in the instantiation of customElem we override both text properties of the definition, and they will have new values if queried. We also support inheritance. Suppose you wanted to extend customElem type above. You can do this as following: anotherElem definition extends customElem x = 30up /anotherElem Here, any element that instantiates anotherElem will have property x equal to 30up, but will preserve all other properties and child elements of customElem . Note that many of the UI elements provided for your convenience are definted using the above mechanism in resUICommon.h","title":"Getting Started"},{"location":"index.html#overview","text":"Each HyperUI application consists of three basic sets of files: Binary data (images, sounds, any custom files, etc.) Text based resource files that specify the entire structure of the user interface, as well as any other text-based data you may need The executable itself, which handles all logic, custom actions, custom rendering, etc. using the above two categories","title":"Overview"},{"location":"index.html#installation","text":"Getting started on your first project is very simple. Please note that for C++ based projects, you need Visual Studio 2015 or newer on Windows, and the latest version of XCode on Mac OS. Hyper UI source and sample projects can be downloaded here: https://github.com/sadcatsoft/hyperui C++ /* - Download and unzip HyperUI to any location of your choice - On Windows, open the HyperUI/examples/blankAppTemplate/msvc2015 solution in Visual Studio - On Mac OS: * In the terminal, run buildLibs to compile the two dependencies, freetype and libpng * Open the HyperUI/examples/blankAppTemplate/macOS project in XCode */ Python pip install hyperui","title":"Installation"},{"location":"index.html#your-first-application","text":"To use HyperUI, it first needs to be initialized. In C++, you need to explicitly do so, while in Python it's done for you when you import the hyperui module: C++ HyperUI :: initialize ( Blank HyperUI App ); // We need to tell our application where the resources from the library // are. In this case, we store them in the subfolder hyperUI relative // to our main application folder. ResourceManager :: setStandardDataPathPrefix ( hyperUI ); Python import hyperui Now, we can create our main window and run the application: C++ // Run it! HyperUI :: run (); Python hyperui . run () When you compile and run the application (C++) or run the script (Python), you should see a blank window appear. Hooray!","title":"Your First Application"},{"location":"index.html#adding-a-button","text":"Well, a window is nice, but pretty useless. How do we make it do something and be actually useful? For that, we need to add some custom UI elements: In the root folder where your Python script or C++ source is located, create a subfolder called \"customUI\". This will server as a folder that contains our custom UI. In that subfolder, crate an empty file named resUI.txt - this will the main file which specifies our user interface elements. Open resUI.txt, and add the following text to it: #include ../hyperUI/config/resUICommon.h window id = mainWindow layer = main fillXLess = 0up fillYLess = 0up button id = testButton text = PRESS ME action = showMessage actionValue = The button has been pressed. Yay! width = 100up /button /window Now that we have created some UI specifications, we need to tell our app to actually use it: C++ // This struct holds optional parameters we can use to customize our window HyperUI :: SWindowParms rParms ; // Here, we tell HyperUI that the UI collection we want to use for our window is resUI.txt // and provide a relative path to it rParms . myInitCollectionType = ResourceManager :: getInstance () - addCollection ( customUI FOLDER_SEP resUI.txt , true ); // Modify the run() call to take these parameters HyperUI :: run ( rParms ); Python # Create a custom Window class that inherits from our base HyperUI window class PyWindow ( hyperui . Window ): def __init__ ( self , file_path , title = , w = - 1 , h = - 1 , first_layer = ): hyperui . Window . __init__ ( self , file_path , title , w , h , first_layer ) # Get the path to where we re running module_path = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ])) # Create a window and provide the full path to our UI specifications file wnd = hyperui . Window ( os . path . join ( module_path , elementsCatalogUI , resUI.txt )) # Tell HyperUI that we want to use our own window class: hyperui . run ( wnd ) Now re-run the application. You should see that the background of the window has changed to a dark texture, and that there is a button in the middle which, when pressed, shows a text box with the confirmation message. We've introduced a lot of new stuff, so let's go line-by-line and explain what's going on here. First, you'll notice that all of our UI and other resource files come in an XML-like (but better :) format, designed first and foremost for readability. Here are some notes on it: The indentation does not matter. Elements are opened using tag tags, and closed using the corresponding /tag . These can be nested. Data is specified using format: propertyName = property value The type of the property is determined automatically. The property must fit on one line. Special syntax exists for specifying longer text segments: text = ___[[[ This is a long piece of text that may be broken up over any number of lines. ]]]___ Properties currently cannot be arbitrary and must be previously declared using DECLARE_PROPERTY() macro in C++ - or be one of existing properties. This is done for performance reasons. We support #ifdef/#endif and #include directives, as well as single-class inheritance. See Advanced section for specifics on these.","title":"Adding a Button"},{"location":"index.html#analysis","text":"Now, what do all those lines mean? Let's start with the first one: #include ../hyperUI/config/resUICommon.h HyperUI is built on the idea that there should be no magic, black-box behaviour - everything should be traceable and logical. The above statement includes the main UI configuration file that specifies default values for elements with tags window and button , and is located using the standard path relative to the location of the file it's included from. You can open it up and see for yourself. id = mainWindow layer = main Each element must have a globally-unique id - which is what the id property specifies in this case. Also, each top-level UI element must have a layer property to be useful - in HyperUI, we show user interface elements not based on telling the program to show a specific window or element, but on showing layers of elements. This means several disjoint elements can be shown all at once with a single command. Here, we specify that the window element in question belongs to the layer named \"main\". Generally, layer names are just custom strings - you can use anything. The \"main\" layer is the exception - by default, these elements will be shown on start up. You can override this behaviour by specifying your own layer name to show when the application launches. fillXLess = 0up fillYLess = 0up What do these mean? And what is this \"up\" thing? \"up\" stands for \"universal pixel\", and is used as a unit of measurement on the screen which scales with the screen density on the specific device the app is running on. This means you can use a single UI configuration for all devices (but don't worry, you can also override it on specific screen densities). The fillXLess property tells HyperUI to stretch this element to fill the main window or its parent element if it has one - less the padding on each side specified by the value of this property. In this case, we want the element to completely fill the window, so the values are set to 0. However, if you set them to 20up and re-run the app, you'll notice that on regular-density screens, there will now be a padding on each side of 20 pixels. action = showMessage actionValue = The button has been pressed. Yay! Clickable elements such as buttons, menus, checkboxes, etc. all can have an action associated with them, as well as parameters that action needs. Some actions are built-in for convenience (\"showMessage\", \"showLayer\", \"hideLayer\", etc.), but you can also add any custom action you want. In this case, we specify that when the button is clicked, we want to show a message and provide its text in the actionValue property.","title":"Analysis"},{"location":"index.html#inheritance","text":"HyperUI resource files support an equavalent to classes and single-class inheritance. The items you have seen in the examples above can all be thought as instances of previously-declared classes. A class, or definition, of an element, is defined as follwoing: customElem definition text = Base text x = 20up anotherElem id = defChildElem text = Child text /anotherElem /customElem customElem id = elemInstance text = Overriding text anotherElem id = defChildElem text = Overriding child text /anotherElem /customElem Here, the first item is the definition of the customElem type. All items that use the same tag after that point in the file will inherit all of the properties of the defintion, as well as all of its children. Also note that in the instantiation of customElem we override both text properties of the definition, and they will have new values if queried. We also support inheritance. Suppose you wanted to extend customElem type above. You can do this as following: anotherElem definition extends customElem x = 30up /anotherElem Here, any element that instantiates anotherElem will have property x equal to 30up, but will preserve all other properties and child elements of customElem . Note that many of the UI elements provided for your convenience are definted using the above mechanism in resUICommon.h","title":"Inheritance"},{"location":"advanced.html","text":"Custom UI Elements and Action Handling In general, custom elements are used in two cases: when there is a custom UI widget that needs to be developed (such, for example, an odometer gauge with custom indicator animation and graphics) or when a screen with many subcontrols needs to be implemented and needs to set the data from the game onto the controls and then modify that data based on the player's actions on that screen. We will focus on the second such case here. Let's say we have an element that spans the entire screen with a single button in the center: uiElem id = helloWorldElement layer = uilMyLayerName elemType = etStatic fillXLess = 0up fillYLess = 0up uiButton id = myButtonTest elemType = etButton width = 200up height = 100up text = Custom Button action = uiaMyCustomAction actionValue = Good Bye! actionValue2 = 3.141592654 /uiButton /uiElem Now, let's add a top-level custom class that can handle the action when the button is pressed. To do so, create and add the two files called UserHelloWorldParent.h and UserHelloWorldParent.cpp to your XCode or Visual Studio solution. If you're using Python, you can just add the corresponding Python snippet to your main script file: C++ // In UserHelloWorldParent.h: #pragma once class UserHelloWorldParent : public UIElement { public : DECLARE_UIELEMENT ( UserHelloWorldParent ); virtual bool handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ); }; // In UserHelloWorldParent.cpp: #include stdafx.h #include UserHelloWorldParent.h UserHelloWorldParent :: UserHelloWorldParent ( UIPlane * pParentPlane ) : UIElement ( pParentPlane ) { onAllocated ( pParentPlane ); } UserHelloWorldParent ::~ UserHelloWorldParent () { onDeallocated (); } void UserHelloWorldParent :: onAllocated ( IBaseObject * pData ) { UIElement :: onAllocated ( pData ); } void UserHelloWorldParent :: onDeallocated () { UIElement :: onDeallocated (); } bool UserHelloWorldParent :: handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ) { bool bDidHandle = false ; return bDidHandle ; } Python class UserHelloWorldParent ( hyperui . UIElement ): def __init__ ( self ): hyperui . UIElement . __init__ ( self ) def handle_action ( self , source_element , action , data ): did_handle = False return did_handle We also need to register our custom element type with HyperUI so it knows it's available. In C++-based projects, you can add the following line after initializing HyperUI; in Python-based projects, you can make the registration call anywhere before you create the main window: C++ REGISTER_CUSTOM_UI_ELEMENT ( UserHelloWorldParent ); Python hyperui . register ( UserHelloWorldParent ) We now need to tell the top-level parent that we want it to be represented by the custom class we've just created. To do that, change the line: elemType = etStatic to: elemType = UserHelloWorldParent This will create one instance of your custom class for every one instance of this UI element. You can now compile the files, since they are fully ready to go. However, they still do nothing. Let's add a handler for our custom button action. In UserHelloWorldParent.cpp , a method called handleAction() exists (in Python, the same method exists in the snippet above). When a button is pressed, the application calls this method first on an element that was clicked, then on its parent, then on the parent of that parent, and so on, until it either reaches the topmost element or until one of these calls returns true , meaning that it handled the action. Let's modify our method as follows: C++ bool UserHelloWorldParent :: handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ) { bool bDidHandle = false ; if ( strAction == uiaMyCustomAction ) { // pSourceElem is the button we clicked // The call below will ask for its action value, which // will return Good Bye! const char * pcsActionValue = pSourceElem - getStringProp ( PropertyActionValue ); // Also, just for kicks, let s ask for the second value. // This will return 3.141592654 FLOAT_TYPE fNumValue2 = pSourceElem - getNumProp ( PropertyActionValue2 ); // Now, let s change the text on the button to the value of its action: this - setUiTextForChild ( myButtonTest , pcsActionValue ); bDidHandle = true ; } return bDidHandle ; } Python def handle_action ( self , source_element , action , data ): did_handle = False if action == uiaMyCustomAction : # pSourceElem is the button we clicked # The call below will ask for its action value, which # will return Good Bye! action_value = source_element . actionValue # Also, just for kicks, let s ask for the second value. # This will return 3.141592654 num_value = source_element . actionValue2 # Now, let s change the text on the button to the value of its action: target_child = self . get_child_by_id ( myButtonTest ) target_child . text = action_value did_handle = True return did_handle You can now compile and run the application. Clicking the button will now change its text to the value of its first action value. Updating UI Elements HyperUI uses an explicit update mechanism. When an event that requires changes to other elements happens, you are expected to trigger the update call as following: C++ // Let s say we re handling an action in a UIElement-based class. // The call below triggers an update for helloWorldElement element and all // of its children. this - getUIPlane () - updateElement ( helloWorldElement ); Python # Let s say we re handling an action in a UIElement-based class. # The call below triggers an update for helloWorldElement element and all # of its children. self . window . update_element ( helloWorldElement ) This triggers the helloWorldElement and all of its child elements to receive the following call: C++ void UserHelloWorldParent :: updateOwnData ( SUpdateInfo rRefreshInfo ) { // Here, you can update anything you want } Python def on_update ( self ): # Here, you can update anything you want pass While this seems like a very basic update mechanism, in practice it turns out sufficient for all but the most complex applications. For the latter, there is a built-in, multi-threaded event-based system, which still needs to be documented. Preprocessor Directives in Resource Files Our resource files support several basic preprocessor defines. In particular, you can include other resource files as following: #include ../hyperUI/config/resUICommon.h Note that the include path is relative to the file it is being included from, and may appear anywhere in the file, including inside existing elements. In C++-based projects, we also support #ifdef and #if defined macros: elem id = testElementId #ifdef MY_CUSTOM_VARIABLE text = Condition 1 #else text = Condition 2 #endif /elem In order to evaluate whether the condition is true or false, it is necessary to provide a custom callback before HyperUI is initialized: class CustomVarCheckCallback : public IVariableDefinedCheckCallback { public : CustomVarCheckCallback () { } virtual ~ CustomVarCheckCallback () { } virtual bool getIsVariableDefined ( const char * pcsVar ) { // Evaluate whether the variable is defined or not according // to your logic and return true or false: return true ; } } // Register it with the ResourceManager: ResourceManager :: getInstance () - setCallback ( new CustomVarCheckCallback ()); Custom Graphics It is also possible to use custom graphics for your application. For this, we need to provide the graphics in the correct location, add a resource file that defines properties on our custom graphics files, and then change our elements to use them. First, in the root folder of your project, create two folders named customGraphics_x1 and customGraphics_x2 . These will contain the two versions of your images - one for regular-density displays, and another for high-density displays. Place your two versions of the png image file into each folder, making sure file dimensions are a power of two (i.e. 32x32). Let's say the file is named sample_icon.png . Next, we need to create a custom resource collection to tell HyperUI that the files is there. In the same folder where your custom UI elements are specified ( customUI ) create another file called resGraphics.txt , and copy-paste the following content there: animation id = customIcon file = sample_icon /animation Above, we basically bind the file name ( sample_icon ) to the id ( customIcon ). In general, this is also the place where we can provide other attributes of the file, such as corner sizes for tiling it, optional compressed texture formats, and other values. Now we need to tell HyperUI to actually load this collection, and use it as an additional graphics collection: C++ // This adds the collection to resource manager using a relative path, // and marks it as a graphics collection. ResourceManager :: getInstance () - addCollection ( customUI FOLDER_SEP resGraphics.txt , true , CollectionRoleGraphics , customGraphics ); Python module_path = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ])) hyperui . add_collection ( os . path . join ( module_path , customUI , resGraphics.txt ), hyperui . CollectionRole . Graphics , os . path . join ( module_path , customGraphics )) Finally, we need to tell the element to actually use this image. We can do that simply by specifying the image property: image = customIcon","title":"Advanced Usage"},{"location":"advanced.html#custom-ui-elements-and-action-handling","text":"In general, custom elements are used in two cases: when there is a custom UI widget that needs to be developed (such, for example, an odometer gauge with custom indicator animation and graphics) or when a screen with many subcontrols needs to be implemented and needs to set the data from the game onto the controls and then modify that data based on the player's actions on that screen. We will focus on the second such case here. Let's say we have an element that spans the entire screen with a single button in the center: uiElem id = helloWorldElement layer = uilMyLayerName elemType = etStatic fillXLess = 0up fillYLess = 0up uiButton id = myButtonTest elemType = etButton width = 200up height = 100up text = Custom Button action = uiaMyCustomAction actionValue = Good Bye! actionValue2 = 3.141592654 /uiButton /uiElem Now, let's add a top-level custom class that can handle the action when the button is pressed. To do so, create and add the two files called UserHelloWorldParent.h and UserHelloWorldParent.cpp to your XCode or Visual Studio solution. If you're using Python, you can just add the corresponding Python snippet to your main script file: C++ // In UserHelloWorldParent.h: #pragma once class UserHelloWorldParent : public UIElement { public : DECLARE_UIELEMENT ( UserHelloWorldParent ); virtual bool handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ); }; // In UserHelloWorldParent.cpp: #include stdafx.h #include UserHelloWorldParent.h UserHelloWorldParent :: UserHelloWorldParent ( UIPlane * pParentPlane ) : UIElement ( pParentPlane ) { onAllocated ( pParentPlane ); } UserHelloWorldParent ::~ UserHelloWorldParent () { onDeallocated (); } void UserHelloWorldParent :: onAllocated ( IBaseObject * pData ) { UIElement :: onAllocated ( pData ); } void UserHelloWorldParent :: onDeallocated () { UIElement :: onDeallocated (); } bool UserHelloWorldParent :: handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ) { bool bDidHandle = false ; return bDidHandle ; } Python class UserHelloWorldParent ( hyperui . UIElement ): def __init__ ( self ): hyperui . UIElement . __init__ ( self ) def handle_action ( self , source_element , action , data ): did_handle = False return did_handle We also need to register our custom element type with HyperUI so it knows it's available. In C++-based projects, you can add the following line after initializing HyperUI; in Python-based projects, you can make the registration call anywhere before you create the main window: C++ REGISTER_CUSTOM_UI_ELEMENT ( UserHelloWorldParent ); Python hyperui . register ( UserHelloWorldParent ) We now need to tell the top-level parent that we want it to be represented by the custom class we've just created. To do that, change the line: elemType = etStatic to: elemType = UserHelloWorldParent This will create one instance of your custom class for every one instance of this UI element. You can now compile the files, since they are fully ready to go. However, they still do nothing. Let's add a handler for our custom button action. In UserHelloWorldParent.cpp , a method called handleAction() exists (in Python, the same method exists in the snippet above). When a button is pressed, the application calls this method first on an element that was clicked, then on its parent, then on the parent of that parent, and so on, until it either reaches the topmost element or until one of these calls returns true , meaning that it handled the action. Let's modify our method as follows: C++ bool UserHelloWorldParent :: handleAction ( string strAction , UIElement * pSourceElem , IBaseObject * pData ) { bool bDidHandle = false ; if ( strAction == uiaMyCustomAction ) { // pSourceElem is the button we clicked // The call below will ask for its action value, which // will return Good Bye! const char * pcsActionValue = pSourceElem - getStringProp ( PropertyActionValue ); // Also, just for kicks, let s ask for the second value. // This will return 3.141592654 FLOAT_TYPE fNumValue2 = pSourceElem - getNumProp ( PropertyActionValue2 ); // Now, let s change the text on the button to the value of its action: this - setUiTextForChild ( myButtonTest , pcsActionValue ); bDidHandle = true ; } return bDidHandle ; } Python def handle_action ( self , source_element , action , data ): did_handle = False if action == uiaMyCustomAction : # pSourceElem is the button we clicked # The call below will ask for its action value, which # will return Good Bye! action_value = source_element . actionValue # Also, just for kicks, let s ask for the second value. # This will return 3.141592654 num_value = source_element . actionValue2 # Now, let s change the text on the button to the value of its action: target_child = self . get_child_by_id ( myButtonTest ) target_child . text = action_value did_handle = True return did_handle You can now compile and run the application. Clicking the button will now change its text to the value of its first action value.","title":"Custom UI Elements and Action Handling"},{"location":"advanced.html#updating-ui-elements","text":"HyperUI uses an explicit update mechanism. When an event that requires changes to other elements happens, you are expected to trigger the update call as following: C++ // Let s say we re handling an action in a UIElement-based class. // The call below triggers an update for helloWorldElement element and all // of its children. this - getUIPlane () - updateElement ( helloWorldElement ); Python # Let s say we re handling an action in a UIElement-based class. # The call below triggers an update for helloWorldElement element and all # of its children. self . window . update_element ( helloWorldElement ) This triggers the helloWorldElement and all of its child elements to receive the following call: C++ void UserHelloWorldParent :: updateOwnData ( SUpdateInfo rRefreshInfo ) { // Here, you can update anything you want } Python def on_update ( self ): # Here, you can update anything you want pass While this seems like a very basic update mechanism, in practice it turns out sufficient for all but the most complex applications. For the latter, there is a built-in, multi-threaded event-based system, which still needs to be documented.","title":"Updating UI Elements"},{"location":"advanced.html#preprocessor-directives-in-resource-files","text":"Our resource files support several basic preprocessor defines. In particular, you can include other resource files as following: #include ../hyperUI/config/resUICommon.h Note that the include path is relative to the file it is being included from, and may appear anywhere in the file, including inside existing elements. In C++-based projects, we also support #ifdef and #if defined macros: elem id = testElementId #ifdef MY_CUSTOM_VARIABLE text = Condition 1 #else text = Condition 2 #endif /elem In order to evaluate whether the condition is true or false, it is necessary to provide a custom callback before HyperUI is initialized: class CustomVarCheckCallback : public IVariableDefinedCheckCallback { public : CustomVarCheckCallback () { } virtual ~ CustomVarCheckCallback () { } virtual bool getIsVariableDefined ( const char * pcsVar ) { // Evaluate whether the variable is defined or not according // to your logic and return true or false: return true ; } } // Register it with the ResourceManager: ResourceManager :: getInstance () - setCallback ( new CustomVarCheckCallback ());","title":"Preprocessor Directives in Resource Files"},{"location":"advanced.html#custom-graphics","text":"It is also possible to use custom graphics for your application. For this, we need to provide the graphics in the correct location, add a resource file that defines properties on our custom graphics files, and then change our elements to use them. First, in the root folder of your project, create two folders named customGraphics_x1 and customGraphics_x2 . These will contain the two versions of your images - one for regular-density displays, and another for high-density displays. Place your two versions of the png image file into each folder, making sure file dimensions are a power of two (i.e. 32x32). Let's say the file is named sample_icon.png . Next, we need to create a custom resource collection to tell HyperUI that the files is there. In the same folder where your custom UI elements are specified ( customUI ) create another file called resGraphics.txt , and copy-paste the following content there: animation id = customIcon file = sample_icon /animation Above, we basically bind the file name ( sample_icon ) to the id ( customIcon ). In general, this is also the place where we can provide other attributes of the file, such as corner sizes for tiling it, optional compressed texture formats, and other values. Now we need to tell HyperUI to actually load this collection, and use it as an additional graphics collection: C++ // This adds the collection to resource manager using a relative path, // and marks it as a graphics collection. ResourceManager :: getInstance () - addCollection ( customUI FOLDER_SEP resGraphics.txt , true , CollectionRoleGraphics , customGraphics ); Python module_path = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ])) hyperui . add_collection ( os . path . join ( module_path , customUI , resGraphics.txt ), hyperui . CollectionRole . Graphics , os . path . join ( module_path , customGraphics )) Finally, we need to tell the element to actually use this image. We can do that simply by specifying the image property: image = customIcon","title":"Custom Graphics"},{"location":"builtInValues.html","text":"Common Properties General Properties Property Description elemType Specifies the type of the element. Built-in types can be found below. Alternatively, this can be custom user class (such as UserMyElement ), in which case the property value is set to the name of the C++ or Python class that you implement. See Custom UI Elements and Action Handling for exact details on how to do that. transitionTime Speicifies the time, in seconds, of the animation length while a layer of elements is being show or hidden. zIndex This is the property that specifies the top-level element's z-order. Its value can be betwee 1 and 14, inclusive. Layers with higher values appear above layers with lower ones. opacity Specifies the opacity, in the range of [0, 1] of an element. Note that unlike imageOpacity , this applies to both the text and the image on the element, as well as all of its children. isHidden A boolean property which defaults to False which, if set to True hides the element (and makes it not clickable). This is used to have some elements hidden and control their visiblity programmatically from C++ or Python upon certain events completing. layer On top-level elements, specifies the name of the layer this element belongs to. Has no effect on child elements. backColor If specified, fills the element with the solid color provided. borderColor If specified, draws a border around the element using the color provided. Note that it must be paired with borderThickness . borderThickness If specified, draws a border around the element of the specified thickness. Note that it must be paired with borderColor . Sizing and Positioning Properties Property Description x, y Specify the position, in ups, of the element. Note that for top-level element, the position is in the range of [0, screenWidth] for X axis and [0, screenHeight] for Y axis. However, for child elements, this is the position relative to their parent's center point, meaning that a child positioned at (0, 0) is located exactly at its parent's center. width, height Specifies the size, in ups, of the element. Note that these are mutually exclusive with their corresponding uioFillParentXLessPadding/uioFillParentYLessPadding properties. Not specifying the element's size using either of these types of properties makes it not clickable. boxOffsetX, boxOffsetY Specifies the offset, if any, in ups, of the element's clickable area. align This property aligns the element to its parent or the screen. It is set to an array of two values, one for horizontal alignment type, one for vertical. Currently, first value can be: - Left - left-align the element's left edge, if it has a valid size, or its center, if it doesn't, to the parent container's left edge. - Center - align the element's center to the parent container's center. Scale the center distance proportionally as the parent grows or shrinks. - Right - right-align the element's right edge, if it has a valid size, or its center, if it doesn't, to the parent container's right edge. - __none__ - do not perform any horizontal alignment. The second value can be one of: - Top - top-align the element's top edge, if it has a valid size, or its center, if it doesn't, to the parent container's top edge. - Center - align the element's center to the parent container's center. Scale the center distance proportionally as the parent grows or shrinks. - Bottom - bottom-align the element's bottom edge, if it has a valid size, or its center, if it doesn't, to the parent container's bottom edge. - __none__ - do not perform any vertical alignment. Note that the \"parent's container\" is defined as the screen area for top-level elements and as their immediate parent's area for children elements. fillXLess, fillYLess These specify that the element is to fill its parent's rectangle area less a certain padding. Each of these is mutually exclusive with a corresponding width/height property. These are used to create elements that automatically resize when their parents do. As above, the parent's area is defined as the screen area for top-level elements and as their immediate parent's area for children elements. The value specified for each of these properties, in ups, is subtract from each side of the parent's contianer. For example, if the parent element is of size 400up x 200up, specifying a child with these two properties set to 40up and 20up, respectively, means that the child element will be of the width (400 - 40*2) = 320up and of the height (200 - 20*2) = 160up. Text Properties Property Description text Specifies the text to show for this element. font Specifies the name of the font object, defined in config/res_fonts.txt and config/res_fonts.txt files. textColor Specifies the color to use when rendering the text of this element, if any. Values can be an array of numbers in the range [0, 1] (e.g. { 0.99, 0.85, 0.01, 0.95 }, which is a yellowish color with 95% opacity) or as hex values (e.g. #ff0000 which would be flat red color). You can also use 255-range values: { 255, 200, 200, 0.1 } textShadowColor Specifies the text drop shadow color. Note that the shadow offset also needs to be non-zero for this property to have any effect. textShadowOffsetX, textShadowOffsetY Offsets, in ups, for the text drop shadow. If not specified or both are 0, no shadow is drawn. textHorAlign Specifies the horizontal alignment of the text relative to the center of the element. Can be one of Left, Center, Right and if not specified, defaults to Center . If the value of Left is specified, the left edge of the text starts at the center of the element and extends further to the right; if the value of Right is set, the text's right edge (i.e. the end of the text) coincides with the element's center X position, and the rest of the text is positioned to the left. textVertAlign Specifies the vertical alignment of the text relative to the center of the element. Can be one of Top, Center, Bottom and if not specified, defaults to Center . If the value of Top is specified, the top edge of the text starts at the center of the element and extends further to the right; if the value of Bottom is set, the text's bottom edge (i.e. the end of the text) coincides with the element's center Y position, and the rest of the text is positioned upwards of the element's center. textOffsetX, textOffsetY Specifies the offset, in ups, of the text relative to its normal position (which includes text alignment). textWidth The value, specified in ups, tells the engine to start automatically wrapping the text if it extends beyond the length of this value. This property is mutually exclusive with textWidthLessPadding . textWidthLessPadding Similar to fillXLess , this property, if specified, forces the text to automatically wrap if it reaches beyond the given size. The size is computed as the size of this element (note: not it's parent) less specified padding from each side. Thus, it the elements width is 400ups, and this value is set to 20ups, the text will start wrapping after it exceeds (400 - 20*2) = 360up in length. textPercOffsetX, textPercOffsetY Similar to textOffsetX/textOffsetY , these propertyes control offset of the text relative to element's center. However, they are specified in the range [-1, 1] and are treated as a percentage of the element's size. For example, specifying the value of -0.5 will offset the text point to the left edge of the element (since it moves it to the left by 50% of the element's total width, and the default starting point is at the center). These properties are useful for controling the text alignment on resizable elements. textIsProtected If set to True, the text is protected and its contents is replaced with asterisks. Useful for password fields. Image Properties Property Description image Specifies the image to draw at the center of the element. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. secondaryImage Used in some more complex UI elements to specify a secondary image. For example, in for a scrollbar, this property specifies the image to use as a background, while image specifies the image to use for the slider knob. backMode If set to fill , the image is intelligently tiled to fill the entire size of the element. If set to scale , the element's image is scaled to fill its size. Otherwise, the image is used untransformed, as it appears in the file. Note that for fill mode, the image definition must include realContentWidth, realContentHeight, cornerW, cornerH properties. overlayColor Specifies the color to overlap on top of the element image. Note that this is usually done with white bitmaps, since overlaying color on multi-color images results in nothing visually pleasing. imageOpacity An opacity value in the range [0, 1] that controls the opacity of this element's image. The default is assumed to be 1.0. imageScale A scale value, in the range of [0, 1] that controls the scale of this element's image. The default is 1.0. Layout Properties Property Description layout If set to column , forces all of its children to be automatically arranged horizontally in columns. The size of each child specified by its width property. You can also override it by providing a layoutWidth property, which, if set to a value greater than 1, specifies an explicit size; if set to a value less than one, it is treated as a percent of the available space (i.e. 0.25 would mean the element will be allocated 25% of the available space). Setting layoutWidth to exactly 1.0 will ensure this element fills any space remaining after computing widths for all other elements in this row. If set to column , forces all of the element's children to be laid out vertically using their computed height. This is useful for laying out forms, for example, where a series of controls each have their own row. You also use the marginTop property on each child to specify top margins for elements. layoutWidth A numeric property that is used to layout the children horizontally when layout is set to column . This value can be either an up pixel width value (e.g. 200up) or, if it is = 1.0, it is treated as a percentage of the space available after all sibling elements with pixel widths have been laid out. Most commonly used with a value 1.0 on a single child while the rest of the children have specific pixel width to fill up the remaining space. marginTop Used in conjuction with uioChildrenAutoLayoutStyle to specify, if needed, the padding at the top of the element in the layout in ups. Action and Interaction Properties Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. isPassthrough If this is set to True, the element, even if it has a valid size set, becomes not clickable, and passes all of the clicks going through to its parent or children, depending on the layout. This is used if one wants to render an overlay over the entire screen but still pass clicks to the elements underneath, for example. Built-In Actions Action Expected Action Values Description showLayer actionValue = layerNameToShow Shows all elements with the specified layer hideLayer actionValue = layerNameToHide Hides all elements with the specified layer hideElement actionValue = elementId Hides a single element with the specified id hideTopParent none Find the top parent of the element which has this action attribute and hides all elements that belong to that layer hideAllLayers none Hides all currently shown layers hideLayerShowLayer actionValue = layerNameToHide actionValue2 = layerNameToShow Hides all elements that belong to the layer specified in actionValue and then shows all elements that belong to the layer specified in actionValue2 hideLastShowLayer actionValue = layerNameToShow Hides the layer that was shown last and then shows all elements with the specified layer showLayerExclusive actionValue = layerNameToShow Hides all layers and then shows the layer specified toggleLayer actionValue = layerName If the specified layer is shown, hides it; if it was hidden, shows it showMessage actionValue = messageContents (optional) actionValue2 = messageTitle Shows a text message with the contents specified in actionValue . If actionValue2 is present, uses its value as a title quitApp none Shuts down the application openFile none Propmpts the application to open a file. Note that you must handle this yourself since the specific requirements vary so much, but can use the provided Application::showOpenFileDialog() function openFolder none Propmpts the application to open a folder. Note that you must handle this yourself since the specific requirements vary so much, but can use the provided Application::showOpenFolderDialog() function acceptNewColorFromPicker none When used in the color picker window, closes it and calls Window::onAcceptNewColorFromPicker() cancelColorPicker none When used in the color picker window, closes it and cancels the color change Built-In Element Types Element Type Description static A static element that contains a piece of text, an image, or both button A button that can be clicked table A vertically-scrolling table with any number of rows and columns. Can contain individually-selectable custom cells. horizontalTable A horizontally-scrolling table. tableCell An element that represents a table or a grid cell. progress A progress bar element. slider A slider with a knob and a sliding range. Can be vertical or horizontal. Scrollbars are also built on this element. zoomWindow A window that shows zoomable and scrollable content (in both direction). Supports pinch-zoom and flicking to pan. textField A single-line text input field. multilineTextField A multiline text input field. checkbox A checkbox that can be toggled on and off. menu A horizontal or vertical menu where each entry can be a direct action item or a submenu. splitter A resizable horizontal or vertical splitter that splits its space into two panes. tabWindow A window that lays out all of its children as tabs. grid A grid that supports laying out items in horizntal-first order. colorSwatch A rectangle which holds a color and supports changing it by using the built-in color picker when clicked. dropdown A dropdown/combobox element. gradientEdit A gradient editing element with preview. roundSlider A knob that can be turned left or right between minimum and maximum values. roundProgress A round progress bar. richText A multi-line text window that supports not only text, but any of the other elements above.","title":"Properties and Element Types"},{"location":"builtInValues.html#common-properties","text":"","title":"Common Properties"},{"location":"builtInValues.html#general-properties","text":"Property Description elemType Specifies the type of the element. Built-in types can be found below. Alternatively, this can be custom user class (such as UserMyElement ), in which case the property value is set to the name of the C++ or Python class that you implement. See Custom UI Elements and Action Handling for exact details on how to do that. transitionTime Speicifies the time, in seconds, of the animation length while a layer of elements is being show or hidden. zIndex This is the property that specifies the top-level element's z-order. Its value can be betwee 1 and 14, inclusive. Layers with higher values appear above layers with lower ones. opacity Specifies the opacity, in the range of [0, 1] of an element. Note that unlike imageOpacity , this applies to both the text and the image on the element, as well as all of its children. isHidden A boolean property which defaults to False which, if set to True hides the element (and makes it not clickable). This is used to have some elements hidden and control their visiblity programmatically from C++ or Python upon certain events completing. layer On top-level elements, specifies the name of the layer this element belongs to. Has no effect on child elements. backColor If specified, fills the element with the solid color provided. borderColor If specified, draws a border around the element using the color provided. Note that it must be paired with borderThickness . borderThickness If specified, draws a border around the element of the specified thickness. Note that it must be paired with borderColor .","title":"General Properties"},{"location":"builtInValues.html#sizing-and-positioning-properties","text":"Property Description x, y Specify the position, in ups, of the element. Note that for top-level element, the position is in the range of [0, screenWidth] for X axis and [0, screenHeight] for Y axis. However, for child elements, this is the position relative to their parent's center point, meaning that a child positioned at (0, 0) is located exactly at its parent's center. width, height Specifies the size, in ups, of the element. Note that these are mutually exclusive with their corresponding uioFillParentXLessPadding/uioFillParentYLessPadding properties. Not specifying the element's size using either of these types of properties makes it not clickable. boxOffsetX, boxOffsetY Specifies the offset, if any, in ups, of the element's clickable area. align This property aligns the element to its parent or the screen. It is set to an array of two values, one for horizontal alignment type, one for vertical. Currently, first value can be: - Left - left-align the element's left edge, if it has a valid size, or its center, if it doesn't, to the parent container's left edge. - Center - align the element's center to the parent container's center. Scale the center distance proportionally as the parent grows or shrinks. - Right - right-align the element's right edge, if it has a valid size, or its center, if it doesn't, to the parent container's right edge. - __none__ - do not perform any horizontal alignment. The second value can be one of: - Top - top-align the element's top edge, if it has a valid size, or its center, if it doesn't, to the parent container's top edge. - Center - align the element's center to the parent container's center. Scale the center distance proportionally as the parent grows or shrinks. - Bottom - bottom-align the element's bottom edge, if it has a valid size, or its center, if it doesn't, to the parent container's bottom edge. - __none__ - do not perform any vertical alignment. Note that the \"parent's container\" is defined as the screen area for top-level elements and as their immediate parent's area for children elements. fillXLess, fillYLess These specify that the element is to fill its parent's rectangle area less a certain padding. Each of these is mutually exclusive with a corresponding width/height property. These are used to create elements that automatically resize when their parents do. As above, the parent's area is defined as the screen area for top-level elements and as their immediate parent's area for children elements. The value specified for each of these properties, in ups, is subtract from each side of the parent's contianer. For example, if the parent element is of size 400up x 200up, specifying a child with these two properties set to 40up and 20up, respectively, means that the child element will be of the width (400 - 40*2) = 320up and of the height (200 - 20*2) = 160up.","title":"Sizing and Positioning Properties"},{"location":"builtInValues.html#text-properties","text":"Property Description text Specifies the text to show for this element. font Specifies the name of the font object, defined in config/res_fonts.txt and config/res_fonts.txt files. textColor Specifies the color to use when rendering the text of this element, if any. Values can be an array of numbers in the range [0, 1] (e.g. { 0.99, 0.85, 0.01, 0.95 }, which is a yellowish color with 95% opacity) or as hex values (e.g. #ff0000 which would be flat red color). You can also use 255-range values: { 255, 200, 200, 0.1 } textShadowColor Specifies the text drop shadow color. Note that the shadow offset also needs to be non-zero for this property to have any effect. textShadowOffsetX, textShadowOffsetY Offsets, in ups, for the text drop shadow. If not specified or both are 0, no shadow is drawn. textHorAlign Specifies the horizontal alignment of the text relative to the center of the element. Can be one of Left, Center, Right and if not specified, defaults to Center . If the value of Left is specified, the left edge of the text starts at the center of the element and extends further to the right; if the value of Right is set, the text's right edge (i.e. the end of the text) coincides with the element's center X position, and the rest of the text is positioned to the left. textVertAlign Specifies the vertical alignment of the text relative to the center of the element. Can be one of Top, Center, Bottom and if not specified, defaults to Center . If the value of Top is specified, the top edge of the text starts at the center of the element and extends further to the right; if the value of Bottom is set, the text's bottom edge (i.e. the end of the text) coincides with the element's center Y position, and the rest of the text is positioned upwards of the element's center. textOffsetX, textOffsetY Specifies the offset, in ups, of the text relative to its normal position (which includes text alignment). textWidth The value, specified in ups, tells the engine to start automatically wrapping the text if it extends beyond the length of this value. This property is mutually exclusive with textWidthLessPadding . textWidthLessPadding Similar to fillXLess , this property, if specified, forces the text to automatically wrap if it reaches beyond the given size. The size is computed as the size of this element (note: not it's parent) less specified padding from each side. Thus, it the elements width is 400ups, and this value is set to 20ups, the text will start wrapping after it exceeds (400 - 20*2) = 360up in length. textPercOffsetX, textPercOffsetY Similar to textOffsetX/textOffsetY , these propertyes control offset of the text relative to element's center. However, they are specified in the range [-1, 1] and are treated as a percentage of the element's size. For example, specifying the value of -0.5 will offset the text point to the left edge of the element (since it moves it to the left by 50% of the element's total width, and the default starting point is at the center). These properties are useful for controling the text alignment on resizable elements. textIsProtected If set to True, the text is protected and its contents is replaced with asterisks. Useful for password fields.","title":"Text Properties"},{"location":"builtInValues.html#image-properties","text":"Property Description image Specifies the image to draw at the center of the element. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. secondaryImage Used in some more complex UI elements to specify a secondary image. For example, in for a scrollbar, this property specifies the image to use as a background, while image specifies the image to use for the slider knob. backMode If set to fill , the image is intelligently tiled to fill the entire size of the element. If set to scale , the element's image is scaled to fill its size. Otherwise, the image is used untransformed, as it appears in the file. Note that for fill mode, the image definition must include realContentWidth, realContentHeight, cornerW, cornerH properties. overlayColor Specifies the color to overlap on top of the element image. Note that this is usually done with white bitmaps, since overlaying color on multi-color images results in nothing visually pleasing. imageOpacity An opacity value in the range [0, 1] that controls the opacity of this element's image. The default is assumed to be 1.0. imageScale A scale value, in the range of [0, 1] that controls the scale of this element's image. The default is 1.0.","title":"Image Properties"},{"location":"builtInValues.html#layout-properties","text":"Property Description layout If set to column , forces all of its children to be automatically arranged horizontally in columns. The size of each child specified by its width property. You can also override it by providing a layoutWidth property, which, if set to a value greater than 1, specifies an explicit size; if set to a value less than one, it is treated as a percent of the available space (i.e. 0.25 would mean the element will be allocated 25% of the available space). Setting layoutWidth to exactly 1.0 will ensure this element fills any space remaining after computing widths for all other elements in this row. If set to column , forces all of the element's children to be laid out vertically using their computed height. This is useful for laying out forms, for example, where a series of controls each have their own row. You also use the marginTop property on each child to specify top margins for elements. layoutWidth A numeric property that is used to layout the children horizontally when layout is set to column . This value can be either an up pixel width value (e.g. 200up) or, if it is = 1.0, it is treated as a percentage of the space available after all sibling elements with pixel widths have been laid out. Most commonly used with a value 1.0 on a single child while the rest of the children have specific pixel width to fill up the remaining space. marginTop Used in conjuction with uioChildrenAutoLayoutStyle to specify, if needed, the padding at the top of the element in the layout in ups.","title":"Layout Properties"},{"location":"builtInValues.html#action-and-interaction-properties","text":"Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. isPassthrough If this is set to True, the element, even if it has a valid size set, becomes not clickable, and passes all of the clicks going through to its parent or children, depending on the layout. This is used if one wants to render an overlay over the entire screen but still pass clicks to the elements underneath, for example.","title":"Action and Interaction Properties"},{"location":"builtInValues.html#built-in-actions","text":"Action Expected Action Values Description showLayer actionValue = layerNameToShow Shows all elements with the specified layer hideLayer actionValue = layerNameToHide Hides all elements with the specified layer hideElement actionValue = elementId Hides a single element with the specified id hideTopParent none Find the top parent of the element which has this action attribute and hides all elements that belong to that layer hideAllLayers none Hides all currently shown layers hideLayerShowLayer actionValue = layerNameToHide actionValue2 = layerNameToShow Hides all elements that belong to the layer specified in actionValue and then shows all elements that belong to the layer specified in actionValue2 hideLastShowLayer actionValue = layerNameToShow Hides the layer that was shown last and then shows all elements with the specified layer showLayerExclusive actionValue = layerNameToShow Hides all layers and then shows the layer specified toggleLayer actionValue = layerName If the specified layer is shown, hides it; if it was hidden, shows it showMessage actionValue = messageContents (optional) actionValue2 = messageTitle Shows a text message with the contents specified in actionValue . If actionValue2 is present, uses its value as a title quitApp none Shuts down the application openFile none Propmpts the application to open a file. Note that you must handle this yourself since the specific requirements vary so much, but can use the provided Application::showOpenFileDialog() function openFolder none Propmpts the application to open a folder. Note that you must handle this yourself since the specific requirements vary so much, but can use the provided Application::showOpenFolderDialog() function acceptNewColorFromPicker none When used in the color picker window, closes it and calls Window::onAcceptNewColorFromPicker() cancelColorPicker none When used in the color picker window, closes it and cancels the color change","title":"Built-In Actions"},{"location":"builtInValues.html#built-in-element-types","text":"Element Type Description static A static element that contains a piece of text, an image, or both button A button that can be clicked table A vertically-scrolling table with any number of rows and columns. Can contain individually-selectable custom cells. horizontalTable A horizontally-scrolling table. tableCell An element that represents a table or a grid cell. progress A progress bar element. slider A slider with a knob and a sliding range. Can be vertical or horizontal. Scrollbars are also built on this element. zoomWindow A window that shows zoomable and scrollable content (in both direction). Supports pinch-zoom and flicking to pan. textField A single-line text input field. multilineTextField A multiline text input field. checkbox A checkbox that can be toggled on and off. menu A horizontal or vertical menu where each entry can be a direct action item or a submenu. splitter A resizable horizontal or vertical splitter that splits its space into two panes. tabWindow A window that lays out all of its children as tabs. grid A grid that supports laying out items in horizntal-first order. colorSwatch A rectangle which holds a color and supports changing it by using the built-in color picker when clicked. dropdown A dropdown/combobox element. gradientEdit A gradient editing element with preview. roundSlider A knob that can be turned left or right between minimum and maximum values. roundProgress A round progress bar. richText A multi-line text window that supports not only text, but any of the other elements above.","title":"Built-In Element Types"},{"location":"elemButton.html","text":"Represents a button with a custom piece of text. Images are also supported by adding a new child element to the button. Tag button elemType button C++ Class UIButtonElement Example button id = testButton text = Press Me action = showMessage actionValue = The button has been pressed. # Optional image if you need it elem id = buttonIcon image = customIcon # Offset it horizontally to the left x = -30up /elem /button Properties Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. image Specifies the image to draw when the button is not pressed. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. image Specifies the image to draw when the button is not pressed. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. Defaults to buttonUpAnim secondaryImage Specifies the image to draw when the button is pressed. Defaults to buttonDownAnim","title":"Button"},{"location":"elemButton.html#example","text":"button id = testButton text = Press Me action = showMessage actionValue = The button has been pressed. # Optional image if you need it elem id = buttonIcon image = customIcon # Offset it horizontally to the left x = -30up /elem /button","title":"Example"},{"location":"elemButton.html#properties","text":"Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. image Specifies the image to draw when the button is not pressed. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. image Specifies the image to draw when the button is not pressed. The value of this property is the value of the id property for the object being referenced in the config/res_prelim_animations.txt or your custom image collection. Defaults to buttonUpAnim secondaryImage Specifies the image to draw when the button is pressed. Defaults to buttonDownAnim","title":"Properties"},{"location":"elemCheckbox.html","text":"Represents a checkbox with a custom piece of text. Tag checkbox elemType checkbox C++ Class UICheckboxElement Example checkbox id = exampleCheckbox text = Checkbox Label width = 200up fillXLess = -1 action = showMessage actionValue = The button has been pressed. /checkbox Properties Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type.","title":"Checkbox"},{"location":"elemCheckbox.html#example","text":"checkbox id = exampleCheckbox text = Checkbox Label width = 200up fillXLess = -1 action = showMessage actionValue = The button has been pressed. /checkbox","title":"Example"},{"location":"elemCheckbox.html#properties","text":"Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type.","title":"Properties"},{"location":"elemColor.html","text":"Represents a color swatch, a label and three RGB values with up/down arrows. When the swatch is clicked, a color picker is brought up in a separate window and assigned to the color swatch when it is closed. Tag color elemType colorSwatch C++ Class UIColorSwatch Example color id = exampleColor fillXLess = 40up /color","title":"Color Element"},{"location":"elemColor.html#example","text":"color id = exampleColor fillXLess = 40up /color","title":"Example"},{"location":"elemDropdown.html","text":"Represents a dropdown element that allows the user to pick one of the listed items. Tag labeledDropdown (or dropdown for the pure dropdown itself with no additional elements) elemType dropdown C++ Class UIDropdown (see also UIDropdownMenu, UIDropdownTextPart) Example dropdown id = exampleDropdown1 fillXLess = 40up menuIds = { __none__, idOption1, idOption2, idOption3 } menuLabels = { __none__, Option 1, Option 2, Option 3 } y = -20up /dropdown Property Description menuIds Specifies ids of the items listed. These are invisibile to the user and are intended for programmatic use. menuLabels These specify user-visible dropdown labels. Please note that the first entry in both menuIds and menuLabels must be __none__ , since it corresponds to the currently selected item.","title":"Dropdown"},{"location":"elemDropdown.html#example","text":"dropdown id = exampleDropdown1 fillXLess = 40up menuIds = { __none__, idOption1, idOption2, idOption3 } menuLabels = { __none__, Option 1, Option 2, Option 3 } y = -20up /dropdown Property Description menuIds Specifies ids of the items listed. These are invisibile to the user and are intended for programmatic use. menuLabels These specify user-visible dropdown labels. Please note that the first entry in both menuIds and menuLabels must be __none__ , since it corresponds to the currently selected item.","title":"Example"},{"location":"elemFixedGrid.html","text":"A fixed grid is very similar to a Grid , but, when resized, instead of putting more cells into the same space, it resizes the cells to match the new size. Therefore, it always remains NxM cells. Tag fixedGrid elemType fixedGrid (and tableCell for each cell element) C++ Class UIFixedGrid (see also UITableCellElement and IFixedGridCellInfoProvider) Example fixedGridSelectableCell id = fixedGridCell borderColor = { 255, 255, 255, 1.0 } /fixedGridSelectableCell fixedGrid id = exampleFixedGrid fillXLess = 40up fillYLess = 40up cellTypes = fixedGridCell numCellsX = 5 numCellsY = 3 /fixedGrid Similarly to regular Tables , a grid searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. Property Description cellTypes A single string value for the uniform cell type for this table. numCellsX Specifies the number of cells per row. numCellsY Specifies the number of cells per column.","title":"Fixed Grid"},{"location":"elemFixedGrid.html#example","text":"fixedGridSelectableCell id = fixedGridCell borderColor = { 255, 255, 255, 1.0 } /fixedGridSelectableCell fixedGrid id = exampleFixedGrid fillXLess = 40up fillYLess = 40up cellTypes = fixedGridCell numCellsX = 5 numCellsY = 3 /fixedGrid Similarly to regular Tables , a grid searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. Property Description cellTypes A single string value for the uniform cell type for this table. numCellsX Specifies the number of cells per row. numCellsY Specifies the number of cells per column.","title":"Example"},{"location":"elemGrid.html","text":"A grid contains a series of cells that are arranged horizontally-first, wrapping at the right edge and continuing onto the next row. It's a convenient layout for displayn an arbitrary, dynamically-determined list of items in the table form. Tag grid elemType grid (and tableCell for each cell element) C++ Class UIGrid (see also UITableCellElement and ITableCellInfoProvider) Example selectableCell id = gridCell borderColor = { 255, 255, 255, 1.0 } fillXLess = -1 fillYLess = -1 width = 64up height = 32up /selectableCell grid id = exampleGrid fillXLess = 40up fillYLess = 40up cellTypes = { gridCell } cellWidth = 64up cellHeight = 32up /grid Similarly to regular Tables , a grid searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. Property Description cellTypes An array with a single value for the uniform cell type for this table. cellWidth Specifies the width of the table cell in the grid. cellHeight Specifies the height of the table cell in the grid.","title":"Grid"},{"location":"elemGrid.html#example","text":"selectableCell id = gridCell borderColor = { 255, 255, 255, 1.0 } fillXLess = -1 fillYLess = -1 width = 64up height = 32up /selectableCell grid id = exampleGrid fillXLess = 40up fillYLess = 40up cellTypes = { gridCell } cellWidth = 64up cellHeight = 32up /grid Similarly to regular Tables , a grid searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. Property Description cellTypes An array with a single value for the uniform cell type for this table. cellWidth Specifies the width of the table cell in the grid. cellHeight Specifies the height of the table cell in the grid.","title":"Example"},{"location":"elemHorTable.html","text":"Represents a horizontally-scrolling table where cells are arranged horizontally. Tag horTable elemType horizontalTable (and tableCell for each cell element) C++ Class UIHorizontalTableElement (see also UITableCellElement and ITableCellInfoProvider) Example selectableCell id = sampleHorCell borderColor = { 255, 255, 255, 1.0 } fillXLess = -1 fillYLess = 5.5up y = -5up width = 64up /selectableCell horTable id = exampleHorTable fillXLess = 40up height = 100up cellTypes = { sampleHorCell } /horTable Similarly to regular Tables , horizontal table searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class.","title":"Horizontal Table"},{"location":"elemHorTable.html#example","text":"selectableCell id = sampleHorCell borderColor = { 255, 255, 255, 1.0 } fillXLess = -1 fillYLess = 5.5up y = -5up width = 64up /selectableCell horTable id = exampleHorTable fillXLess = 40up height = 100up cellTypes = { sampleHorCell } /horTable Similarly to regular Tables , horizontal table searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class.","title":"Example"},{"location":"elemInput.html","text":"Represents a single-line text or number input field. Comes with its own label. Tag stringInput elemType textField C++ Class UITextFieldElement Example stringInput id = exampleStringInput fillXLess = 40up elem id = defLabel text = My Label /elem elem id = defTextBox text = Initial text /elem /stringInput Property Description textFormat Specifies the format, in C notation, to display the value in, such as %d . Note that specifying numeric formats ( %d, %g, %f ) will convert this field to a numeric field where only numbers will be allowed. This property is ignored for non-numeric fields. min For numeric input fields, the minimum value that can be displayed. max For numeric input fields, the maximum value that can be displayed. text Specifies the default text value. textIsProtected If True , the characters are replaced with asterisks. Defaults to False . lostFocusAction A string value that represents the action to trigger when the input field loses focus. textChangedAction A string value that represents the action to trigger when the text in the input field changes. isReadOnly If True , existing text cannot be edited by the user.","title":"Single-line Input"},{"location":"elemInput.html#example","text":"stringInput id = exampleStringInput fillXLess = 40up elem id = defLabel text = My Label /elem elem id = defTextBox text = Initial text /elem /stringInput Property Description textFormat Specifies the format, in C notation, to display the value in, such as %d . Note that specifying numeric formats ( %d, %g, %f ) will convert this field to a numeric field where only numbers will be allowed. This property is ignored for non-numeric fields. min For numeric input fields, the minimum value that can be displayed. max For numeric input fields, the maximum value that can be displayed. text Specifies the default text value. textIsProtected If True , the characters are replaced with asterisks. Defaults to False . lostFocusAction A string value that represents the action to trigger when the input field loses focus. textChangedAction A string value that represents the action to trigger when the text in the input field changes. isReadOnly If True , existing text cannot be edited by the user.","title":"Example"},{"location":"elemKnob.html","text":"Represents a rotary knob, also known as a round slider, that can rotate and change a value between given minimum and maximum values. Comes with a label and an updateable numeric input control. Tag numericRoundSlider (or angle for the pure knob itself with no additional elements) elemType roundSlider C++ Class UIRoundSliderElement Example numericRoundSlider id = exampleKnob y = 25up fillXLess = 40up elem id = defLabel text = My Label /elem /numericRoundSlider Property Description image Specifies the empty progress bar image. secondaryImage Optionally specifies the full progress bar image. capImage Optionally, provide a cap image that is rotated by an appropriate amount and rendered on top of the previous two images.","title":"Rotary Knob"},{"location":"elemKnob.html#example","text":"numericRoundSlider id = exampleKnob y = 25up fillXLess = 40up elem id = defLabel text = My Label /elem /numericRoundSlider Property Description image Specifies the empty progress bar image. secondaryImage Optionally specifies the full progress bar image. capImage Optionally, provide a cap image that is rotated by an appropriate amount and rendered on top of the previous two images.","title":"Example"},{"location":"elemMenu.html","text":"Represents any kind of meny in the program. Can be a horizontal menu bar or a vertical submenu with other child items. Can also be used for context (right-mouse button) menus. Tag mainMenu for main menus, submenu for submenus elemType menu C++ Class UIMenuElement Example mainMenu id = exampleMenu menuIds = { idFile, idEdit } menuLabels = { File, Edit } menuSubitems = { exampleFileSubmenu, exampleEditSubmenu } menuActions = { __none__, __none__ } menuActionValues = { __none__, __none__ } /mainMenu submenu id = exampleFileSubmenu layer = uilFileSubmenu menuIds = { idFileOption1, __sep__, idFileOption2 } menuLabels = { Show Test Message, __none__, Another Menu Item } menuActions = { showMessage, __none__, __none__ } menuActionValues = { File Option 1 has been clicked., __none__, __none__ } /submenu submenu id = exampleEditSubmenu layer = uilEditSubmenu menuIds = { idEditOption1, __sep__, idEditOption2 } menuLabels = { Edit Option 1, __none__, Edit Option 2 } menuActions = { __none__, __none__, __none__ } /submenu Note that for all properties below, each is an array, and all arrays that are provided must be the same length. Property Description menuIds Specifies ids of the items listed. These are invisibile to the user and are intended for programmatic use. To specify a separator, use __sep__ menuLabels An array that specifies specify user-visible dropdown labels. menuActions An array that speicifies each item's action to trigger. menuActionValues, menuActionValues2, menuActionValues3 An array that speicifies each item's action values, up to three per item. menuIcons Optionally, specify icons for each menu item. menuSubitems If a menu item contains a submenu, this is the id of each submenu. Otherwise, should be set to __none__ . menuIsCheckmark If set to True , the item is checkbox that can be toggled on and off; if set to False , each item is a regular menu item. menuCheckmarkImage A string (not an array) property that specifies the image to use for the checkmark.","title":"Menu"},{"location":"elemMenu.html#example","text":"mainMenu id = exampleMenu menuIds = { idFile, idEdit } menuLabels = { File, Edit } menuSubitems = { exampleFileSubmenu, exampleEditSubmenu } menuActions = { __none__, __none__ } menuActionValues = { __none__, __none__ } /mainMenu submenu id = exampleFileSubmenu layer = uilFileSubmenu menuIds = { idFileOption1, __sep__, idFileOption2 } menuLabels = { Show Test Message, __none__, Another Menu Item } menuActions = { showMessage, __none__, __none__ } menuActionValues = { File Option 1 has been clicked., __none__, __none__ } /submenu submenu id = exampleEditSubmenu layer = uilEditSubmenu menuIds = { idEditOption1, __sep__, idEditOption2 } menuLabels = { Edit Option 1, __none__, Edit Option 2 } menuActions = { __none__, __none__, __none__ } /submenu Note that for all properties below, each is an array, and all arrays that are provided must be the same length. Property Description menuIds Specifies ids of the items listed. These are invisibile to the user and are intended for programmatic use. To specify a separator, use __sep__ menuLabels An array that specifies specify user-visible dropdown labels. menuActions An array that speicifies each item's action to trigger. menuActionValues, menuActionValues2, menuActionValues3 An array that speicifies each item's action values, up to three per item. menuIcons Optionally, specify icons for each menu item. menuSubitems If a menu item contains a submenu, this is the id of each submenu. Otherwise, should be set to __none__ . menuIsCheckmark If set to True , the item is checkbox that can be toggled on and off; if set to False , each item is a regular menu item. menuCheckmarkImage A string (not an array) property that specifies the image to use for the checkmark.","title":"Example"},{"location":"elemMultilineInput.html","text":"Represents a multi-line text input field that comes with its own label. Tag multilineInput elemType multilineTextField C++ Class UIMultilineTextFieldElement Example multilineInput id = exampleMultilineInput fillXLess = 40up elem id = defLabel text = My Label /elem /multilineInput Property Description text Specifies the default text value. lostFocusAction A string value that represents the action to trigger when the input field loses focus. textChangedAction A string value that represents the action to trigger when the text in the input field changes. isReadOnly If True , existing text cannot be edited by the user.","title":"Multi-line Input"},{"location":"elemMultilineInput.html#example","text":"multilineInput id = exampleMultilineInput fillXLess = 40up elem id = defLabel text = My Label /elem /multilineInput Property Description text Specifies the default text value. lostFocusAction A string value that represents the action to trigger when the input field loses focus. textChangedAction A string value that represents the action to trigger when the text in the input field changes. isReadOnly If True , existing text cannot be edited by the user.","title":"Example"},{"location":"elemProgressBar.html","text":"Represents a horizontal progress bar, with optional text. Tag progress elemType progress C++ Class UIProgressElement Example progress id = exampleProgressBar text = Completion: textOffsetX = -75up textOffsetY = -0.5up textHorAlign = Right /progress Property Description image Specifies the empty progress bar image. secondaryImage Optionally specifies the full progress bar image. direction Optionally, specifies the direction from which the progress bar begins at zero progress. The default is FromLeft , but it can be one of the following values: - FromLeft - begins drawing the progress bar from the left - FromRight - begins drawing the progress bar from the right - FromTop - begins drawing the progress bar from the top - FromLeft - begins drawing the progress bar from the bottom Note that for vertical values, corresponding vertical images are expected","title":"Progress Bar"},{"location":"elemProgressBar.html#example","text":"progress id = exampleProgressBar text = Completion: textOffsetX = -75up textOffsetY = -0.5up textHorAlign = Right /progress Property Description image Specifies the empty progress bar image. secondaryImage Optionally specifies the full progress bar image. direction Optionally, specifies the direction from which the progress bar begins at zero progress. The default is FromLeft , but it can be one of the following values: - FromLeft - begins drawing the progress bar from the left - FromRight - begins drawing the progress bar from the right - FromTop - begins drawing the progress bar from the top - FromLeft - begins drawing the progress bar from the bottom Note that for vertical values, corresponding vertical images are expected","title":"Example"},{"location":"elemRadioButton.html","text":"Represents a radio button with a custom piece of text. Note that it uses exactly the same implementation as a checkbox, but with different images and a radioGroup property added. Tag radioButton elemType checkbox C++ Class UICheckboxElement Example radioButton id = exampleRadioButton1 text = Option 1 width = 200up fillXLess = -1 x = 100up y = -20up radioGroup = ___myExampleGroup___ /radioButton radioButton id = exampleRadioButton2 text = Option 2 width = 200up fillXLess = -1 x = 100up radioGroup = ___myExampleGroup___ /radioButton radioButton id = exampleRadioButton3 text = Option 3 width = 200up fillXLess = -1 x = 100up y = 20up radioGroup = ___myExampleGroup___ /radioButton Properties Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. radioGroup Specifies a string label for a group of radio boxes. This label is arbitrary, but all radio boxes with the same label will be mutually exclusive - i.e the user will only be able to select one of them at a time.","title":"Radio Button"},{"location":"elemRadioButton.html#example","text":"radioButton id = exampleRadioButton1 text = Option 1 width = 200up fillXLess = -1 x = 100up y = -20up radioGroup = ___myExampleGroup___ /radioButton radioButton id = exampleRadioButton2 text = Option 2 width = 200up fillXLess = -1 x = 100up radioGroup = ___myExampleGroup___ /radioButton radioButton id = exampleRadioButton3 text = Option 3 width = 200up fillXLess = -1 x = 100up y = 20up radioGroup = ___myExampleGroup___ /radioButton","title":"Example"},{"location":"elemRadioButton.html#properties","text":"Property Description action Specifies the action string to process when an element is clicked. This string is passed up to every parent in the change through the handleAction method which can be overriden by a custom element or handled in the window class. The unprocessed or global actions are processed automatically or ignored if the action is custom. actionValue, actionValue2, actionValue3 Action values passed along with the action type itself. These can be anything and are specific to each particular action type. radioGroup Specifies a string label for a group of radio boxes. This label is arbitrary, but all radio boxes with the same label will be mutually exclusive - i.e the user will only be able to select one of them at a time.","title":"Properties"},{"location":"elemRichText.html","text":"Represents an non-editable, multi-line text element that can contain other arbitrary elements in the text flow. The user can optionally interact with these contained elements if they support it (such as clicking a button, for example). Tag richText elemType richText C++ Class UIRichTextElement Example button id = richTextButton width = 150up /button richText id = exampleRichText fillXLess = 100up fillYLess = 40up borderColor = { 255, 255, 255, 0.8 } borderThickness = 0.25up elem id = defContent text = ___[[[This is an example of plain-text content, with a button with a customized text and action below.^ {richTextButton rtPaddingLeft=10up text=___(((Custom Button)))___ action=showMessage actionValue=___(((Test message)))___}]]]___ /elem /richText Inner Document Format Note that multi-line text can be specified using the ___[[[ ...multi-line text here... ]]]___ notation. Also note that the ^ symbol forces a line break. The format of elements within the text is as follows: {elementId rtPaddingLeft=10up property1=___(((stringValue1)))___ property2=___(((stringValue2)))___ ... } elementId An id of the element defined at the top level (i.e. not a child element of any other element) to use in this location. rtPaddingLeft An optional left-side padding for the element in universal pixels. property1, property2, ... These are optional properties to override on the element defined by elementId , and are useful in case the same element needs trigger different actions or display a different piece of text. For example, you can reuse the same button element, but specify text=___(((Custom Button Text)))___","title":"Rich Text Element"},{"location":"elemRichText.html#example","text":"button id = richTextButton width = 150up /button richText id = exampleRichText fillXLess = 100up fillYLess = 40up borderColor = { 255, 255, 255, 0.8 } borderThickness = 0.25up elem id = defContent text = ___[[[This is an example of plain-text content, with a button with a customized text and action below.^ {richTextButton rtPaddingLeft=10up text=___(((Custom Button)))___ action=showMessage actionValue=___(((Test message)))___}]]]___ /elem /richText","title":"Example"},{"location":"elemRichText.html#inner-document-format","text":"Note that multi-line text can be specified using the ___[[[ ...multi-line text here... ]]]___ notation. Also note that the ^ symbol forces a line break. The format of elements within the text is as follows: {elementId rtPaddingLeft=10up property1=___(((stringValue1)))___ property2=___(((stringValue2)))___ ... } elementId An id of the element defined at the top level (i.e. not a child element of any other element) to use in this location. rtPaddingLeft An optional left-side padding for the element in universal pixels. property1, property2, ... These are optional properties to override on the element defined by elementId , and are useful in case the same element needs trigger different actions or display a different piece of text. For example, you can reuse the same button element, but specify text=___(((Custom Button Text)))___","title":"Inner Document Format"},{"location":"elemSlider.html","text":"Represents a horizontal slider for numeric values with a label and an auto-updating text field. Tag numericSlider (or slider for the slider itself with no other elements attached) elemType slider C++ Class UISliderElement Example numericSlider id = exampleNumericSlider fillXLess = 40up elem id = defLabel text = My Label /elem elem id = defNumSliderSlider max = 100 /elem /numericSlider Properties Property Description image Specifies the empty slider image. secondaryImage Optionally specifies the full slider image. startInMiddle If True , the zero knob position vill be in the middle of the slider; if False , it will be on the far left. The default is False . max Optionally, specify a maximum value for the slider. The default is 1.0. min Optionally, specify a minimum value for the slider. If the slider starts in the middle, the default value is -1; otherwise, it's 0. textFormat If the image for a pop up while dragging the slider is provided, this value specifies how to display the current slider value in C notation. The defeault value is %d sliderButtonSizes Optionally, specifies the increment and decrement button clickable areas as a list of two numbers. The first number is the width of the button, the second is the height. Requires button images to be provided via sliderParms option. For example: `sliderButtonSizes = { 20up, 20up } sliderParms A list of up to four values that specify images to use for the slider. The first value is the image to use of the decrement button, or __none__ if none; the second is the image for the increment button, or __none__ for no button visible. The third value is an image to use to fill in the full (left) part of the slider. Finally, the last image is an option image for the pop up display of value as the slider is being dragged. For example: sliderParms = { __none__, __none__, progressFull, sliderPopAnim } sliderMarkParms Optionally, specifies the parameters for marks (vertical dashes) along the slider. This is an array of two numbers, the first of which denotes the mark spacing, in universal pixels, and the second denotes how many small marks are drawn before the large one is. For example: sliderMarkParms = { 2up, 10 } sliderMarkColor For cases where marks are specified, provides the color to use for those marks. For example: sliderMarkColor = { 0.230, 0.230, 0.230, 1.0 } sliderValParms If the pop up image is specified, this optional array can specify an array of two numbers, the first of which is the vertical offset of the value text in the popup, and the second is an optional multiplier to apply to the actual slider value before it is displayed. For example: sliderValParms = { -15up, 1.0 }","title":"Slider"},{"location":"elemSlider.html#example","text":"numericSlider id = exampleNumericSlider fillXLess = 40up elem id = defLabel text = My Label /elem elem id = defNumSliderSlider max = 100 /elem /numericSlider","title":"Example"},{"location":"elemSlider.html#properties","text":"Property Description image Specifies the empty slider image. secondaryImage Optionally specifies the full slider image. startInMiddle If True , the zero knob position vill be in the middle of the slider; if False , it will be on the far left. The default is False . max Optionally, specify a maximum value for the slider. The default is 1.0. min Optionally, specify a minimum value for the slider. If the slider starts in the middle, the default value is -1; otherwise, it's 0. textFormat If the image for a pop up while dragging the slider is provided, this value specifies how to display the current slider value in C notation. The defeault value is %d sliderButtonSizes Optionally, specifies the increment and decrement button clickable areas as a list of two numbers. The first number is the width of the button, the second is the height. Requires button images to be provided via sliderParms option. For example: `sliderButtonSizes = { 20up, 20up } sliderParms A list of up to four values that specify images to use for the slider. The first value is the image to use of the decrement button, or __none__ if none; the second is the image for the increment button, or __none__ for no button visible. The third value is an image to use to fill in the full (left) part of the slider. Finally, the last image is an option image for the pop up display of value as the slider is being dragged. For example: sliderParms = { __none__, __none__, progressFull, sliderPopAnim } sliderMarkParms Optionally, specifies the parameters for marks (vertical dashes) along the slider. This is an array of two numbers, the first of which denotes the mark spacing, in universal pixels, and the second denotes how many small marks are drawn before the large one is. For example: sliderMarkParms = { 2up, 10 } sliderMarkColor For cases where marks are specified, provides the color to use for those marks. For example: sliderMarkColor = { 0.230, 0.230, 0.230, 1.0 } sliderValParms If the pop up image is specified, this optional array can specify an array of two numbers, the first of which is the vertical offset of the value text in the popup, and the second is an optional multiplier to apply to the actual slider value before it is displayed. For example: sliderValParms = { -15up, 1.0 }","title":"Properties"},{"location":"elemSplitter.html","text":"Represents a horizontal or vertical splitter, each of which contains exactly two child elements whose size is automatically managed to split its parent element into to. Cna be resized or fixed. Tag vertSplitter for vertical splitter, horSplitter for a horizontal one. elemType splitter C++ Class UISplitterElement Example vertSplitter id = exampleSplitterVert fillXLess = 40up height = 150up borderColor = { 255, 255, 255, 0.8 } borderThickness = 0.5up y = -90up elem id = exampleSplitterVertLeft backColor = #ff7800 /elem elem id = exampleSplitterVertRight backColor = #00baff /elem /vertSplitter Property Description isVertical If set to True , the splitter is a vertical splitter; if set to False , it becomes a horizontal splitter. splitterFixedChildIndex Optionally, specifies the child index (0 or 1) that is kept constant size as the splitter is resized. If omitted, both child elements are reszied proportionately. splitterDisableResizing If set to True , the splitter is a fixed splitter and cannot be resized by the user. splitterPos Specifies the initial splitter position. If the value is greater than 1.0, the position is assumed to be a pixel position from the left for vertical splitters, and from the top for horizontal ones. If the value is betwee 0 and 1, this is assumed to be a ratio of the parent element's size.","title":"Splitter"},{"location":"elemSplitter.html#example","text":"vertSplitter id = exampleSplitterVert fillXLess = 40up height = 150up borderColor = { 255, 255, 255, 0.8 } borderThickness = 0.5up y = -90up elem id = exampleSplitterVertLeft backColor = #ff7800 /elem elem id = exampleSplitterVertRight backColor = #00baff /elem /vertSplitter Property Description isVertical If set to True , the splitter is a vertical splitter; if set to False , it becomes a horizontal splitter. splitterFixedChildIndex Optionally, specifies the child index (0 or 1) that is kept constant size as the splitter is resized. If omitted, both child elements are reszied proportionately. splitterDisableResizing If set to True , the splitter is a fixed splitter and cannot be resized by the user. splitterPos Specifies the initial splitter position. If the value is greater than 1.0, the position is assumed to be a pixel position from the left for vertical splitters, and from the top for horizontal ones. If the value is betwee 0 and 1, this is assumed to be a ratio of the parent element's size.","title":"Example"},{"location":"elemStatic.html","text":"A static element provides the ability to show text, image, or both. It is usually not given a size, unless you want it to be outlines or filled with a background color. All elements in HyperUI inherit from this type. Tag elem elemType static C++ Class UIElement Example elem id = exampleElement layer = main text = This is an example of static text element. image = customIcon x = -10up y = 20up width = 200up height = 100up /elem Properties The static UI element supports all of the standard properties described in Properties and Element Types .","title":"Static Element"},{"location":"elemStatic.html#example","text":"elem id = exampleElement layer = main text = This is an example of static text element. image = customIcon x = -10up y = 20up width = 200up height = 100up /elem","title":"Example"},{"location":"elemStatic.html#properties","text":"The static UI element supports all of the standard properties described in Properties and Element Types .","title":"Properties"},{"location":"elemTable.html","text":"Represents a vertically-scrolling, single- or multi-column table that supports per-row or per-cell selection (or none at all), with custom elements that can be optionally configured per cell. Tag table elemType table (and tableCell for each cell element) C++ Class UITableElement (see also UITableCellElement and ITableCellInfoProvider) Example selectableCell id = sampleCell borderColor = { 255, 255, 255, 1.0 } /selectableCell table id = exampleVertTable fillXLess = 40up fillYLess = 40up cellTypes = { sampleCell } /table Note that when table is being generated, it first searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. If it doesn't find one, or if the value returned is invalid, it attempts to query the properties listed below on the table instead. In practice, this means you can make a parent element of the window responsible for dynamically determining table behaviour instead of relying on the properties below. Property Description perCellSelection A boolean property that specifies whether the table should do per-cell or per-row selection. The value of True means per-cell selection. Defaults to False . allowSelection A boolean value that specifies whether the table supports selection at all or not. Defaults to False . allowMultipleSelection A boolean value that specifies whether multiple cells or rows (depending on the value of perCellSelection above) can be selected at once. numColumns Specifies the number of columns in this table. Defaults to 1. cellTypes An array of cell types whose length must match the value of numColumns above. Specifies the ids of elements to use for cells in each column. rmbAction Optional element that specifies the action to trigger when the right-mouse button is pressed over the table. cellSpacing Optionally, specifies the spacing (padding) for all cells, both on the x and y axis. cellSelectionElem Optionally, specifies the id of an element to show when the cell or row is selected. This is done automatically for convenience.","title":"Table"},{"location":"elemTable.html#example","text":"selectableCell id = sampleCell borderColor = { 255, 255, 255, 1.0 } /selectableCell table id = exampleVertTable fillXLess = 40up fillYLess = 40up cellTypes = { sampleCell } /table Note that when table is being generated, it first searches all of its parents (and itself) for any class that implements the ITableCellInfoProvider interface. If it finds one, it queries all the values necessary for table construction from that class. If it doesn't find one, or if the value returned is invalid, it attempts to query the properties listed below on the table instead. In practice, this means you can make a parent element of the window responsible for dynamically determining table behaviour instead of relying on the properties below. Property Description perCellSelection A boolean property that specifies whether the table should do per-cell or per-row selection. The value of True means per-cell selection. Defaults to False . allowSelection A boolean value that specifies whether the table supports selection at all or not. Defaults to False . allowMultipleSelection A boolean value that specifies whether multiple cells or rows (depending on the value of perCellSelection above) can be selected at once. numColumns Specifies the number of columns in this table. Defaults to 1. cellTypes An array of cell types whose length must match the value of numColumns above. Specifies the ids of elements to use for cells in each column. rmbAction Optional element that specifies the action to trigger when the right-mouse button is pressed over the table. cellSpacing Optionally, specifies the spacing (padding) for all cells, both on the x and y axis. cellSelectionElem Optionally, specifies the id of an element to show when the cell or row is selected. This is done automatically for convenience.","title":"Example"},{"location":"exampleProjects.html","text":"We provide three example projects in C++ and two in Python to help you get started: Blank App Template This is a template using C++ for Windows and macOS which is just a blank application with a custom UI collection with a single button setup for you. It's convenient to use as a starting point for your own applications - you can just make a copy of it and start creating. Located in : $HYPERUI_ROOT\\examples\\blankAppTemplate Simple Window This example builds on the previous one and shows how to create custom window objects and custom UI element objects. It also shows how to handle custom actions, key presses, and other events from the application. Located in : $HYPERUI_ROOT\\examples\\simpleWindow Elements Catalog This example is a comprehensive catalog of every built-in UI element that is available to you. It's convenient to be aware of the tools you have, and is useful for seeing how the elements are specified in the real-world use scenario. It's also useful since you can quickly copy-paste desired elements into your own code. Located in : $HYPERUI_ROOT\\examples\\elementsCatalog","title":"Example Projects"},{"location":"exampleProjects.html#blank-app-template","text":"This is a template using C++ for Windows and macOS which is just a blank application with a custom UI collection with a single button setup for you. It's convenient to use as a starting point for your own applications - you can just make a copy of it and start creating. Located in : $HYPERUI_ROOT\\examples\\blankAppTemplate","title":"Blank App Template"},{"location":"exampleProjects.html#simple-window","text":"This example builds on the previous one and shows how to create custom window objects and custom UI element objects. It also shows how to handle custom actions, key presses, and other events from the application. Located in : $HYPERUI_ROOT\\examples\\simpleWindow","title":"Simple Window"},{"location":"exampleProjects.html#elements-catalog","text":"This example is a comprehensive catalog of every built-in UI element that is available to you. It's convenient to be aware of the tools you have, and is useful for seeing how the elements are specified in the real-world use scenario. It's also useful since you can quickly copy-paste desired elements into your own code. Located in : $HYPERUI_ROOT\\examples\\elementsCatalog","title":"Elements Catalog"},{"location":"uiConcepts.html","text":"Specifying UI The UI for each window is specified in a single UI specification file, such as resUI.txt. Each of these files is called a resource collection, and can be accessed through HyperUI::ResourceManager . As a note, you can also use this mechanism to load any other kind of data you need, not just UI elements. At this point, you might wonder why is there a single file instead of individual files for each UI element. This was a deliberate decision to avoid making things more complicated than they need to be (in terms of both structure and the necessary build process changes that would have been required), as well as for performance reasons, since a single file is faster to load and parse. However, you can use #include directives to break up that file into multiple files and include them into the project. UI Element Types Each UI element has a type, which determines its behaviour. These are described in the \"UI Elements\" section. The most basic element type is \"static\", and it can specify either a label (text) or an image - or both. Both can be controlled and offset individually. For example: elem id = elem1 text = This is a sample label image = windowBackground /elem Here, both the text and the image will be drawn at the center of the element, but can be offset: elem id = elem1 text = This is a sample label image = windowBackground textOffsetX = 20up textOffsetY = 10up imageOffsetX = -50up imageOffsetY = -25up /elem Now, the text will be shifted 20 universal pixels to the right and 10 universal pixels down, while the image will be shifted 50 universal pixels up and 25 universal pixels to the left. For more options on what else can be done with static elements, please see the Static Element documentation. Note that the image value of windowBackground refers to an entry in the graphics resource collection, not the file directly. Layers Most UI systems show and hide UI elements directly and individually - that is, they expect you to say \"show (or hide) an element with id X\". In our system, we use layers of UI elements instead; each top-level UI element must have a layer property, which is set to any simple custom string, i.e.: layer = myCustomLayerName . A layer can then be shown using a showUI(\"myCustomLayerName\") function call. This method has several advantages: There are fewer hard-coded strings in the code, since there are fewer layer names in the code than individual element ids It is much easier to show several UI elements at the same time, especially if each of them has its own animation style, than individually showing each one using ids Universal Pixels All distances and sizes in HyperUI are all specified in \"universal pixels\" - abbreviated as \"up\". The reasoning behind this is that HyperUI runs on many devices with different screen densities, and we want to specify the UI only once. So, if you specify an element width of \"100up\", it will be automatically converted to 100 pixels on a non-Retina laptop display, but to 200 pixels on a Retina one. This ensures that the button remains the same size on the physical screen of the device. Element Positioning Our elements are positioned using the XY system with the origin in the top-left corner of the screen, similar to many other UI systems. Similarly, like other systems, each UI element has an (x,y) position and a size. However, unlike most other systems where the element position usually denotes where its top-left corner is positioned, in our system, it denotes where the center of the element is. This approach makes it much easier to nest and transform elements. By default, an element is poitioned at (0, 0), which means: If the element is a top-level element and has no parent, it is positioned in the center of the screen If the element has a parent, it is positioned at the center of the parent element You can change an element's position by modifying it's x and y properties: elem id = elem1 x = 200up y = 100up /elem It will now be offset by 200 universal pixels horizontall and 100 universal pixels vertically from its (0,0) position. In general, you can think of x and y properties as offsets from where the element would have otherwise been given all other flags on it (such as alignment). Aligning Elements To make UI elements more adaptible and scalable, elements can be automatically aligned to its parent's element area (or the entire screen if the element is a top-level element). To do this, you can add an align property to the element. This property is an array of two elements, where the first one specifies horizontal alignment, and the second specifies vertical alignment: elem id = elem1 align = { Right, Bottom } /elem Since this is a top-level element with no parent, it will be aligned to the right-bottom corner of the screen. Note that if the element has a size, then the element's right-bottom corner will be aligned to the right-bottom corner of the screen; however, if the element has a zero size, then its center will be aligned to that screen corner. What if you want to align an element only on one axis? You can always specify __none___ as the other array element to avoid performing any alignment at all: align = { Right, __none__} What if you want to align the same element to the bottom-right corner of the screen, but also offset it a little? Well, it's easy and logical - you just specify its new position The following values are accepted for the first (horizontal) align flag: Value Meaning Left Aligns the element to the left boundary of the parent element or screen Center Aligns the element to the center of the parent element or screen, proportionately scaling the offset specified by the element's x value when the window size changes Right Aligns the element to the right boundary of the parent element or screen __none__ Does not align the element horizontally The following values are accepted for the second (vertical) align flag: Value Meaning Top Aligns the element to the top boundary of the parent element or screen Center Aligns the element to the center of the parent element or screen, proportionately scaling the offset specified by the element's y value when the window size changes Bottom Aligns the element to the bottom boundary of the parent element or screen __none__ Does not align the element vertically Specifying Size By default, an element has no size. This means it cannot be clicked, for example. It also means its image cannot be stretched or tiled to fill it, and all alignment will be done on its center, instead of on its actual area. Two of the most common ways of specifying the size are by setting a static size or by setting the size as a portion of its parent's size. To specify a static size, you can simply set the element's width and height property: button id = elem1 width = 200up height = 100up /button This button is now 200 universal pixels wide and 100 universal pixels tall. This, however, is an approach that works well only for a specific subset of cases. It is often the case that an element needs to resizable. In this case, we can use the following properties: elem id = elem1 fillXLess = 20up fillYLess = 10up /elem This element will be now be the same size as its parent less a padding of 20 universal pixels on each side horizontally, and 10 universal pixels on each top and bottom. This approach is often useful when dividing the screen or an element into sections that need to be resizable. These can also be mixed - that is, an element's width can be specified using the fillXLess property, but it's height can be specified using the height property - or vice versa. Layout Types There are three main methods of laying out the user interface elements in our platform. Explicit Positioning In this method, children of an element are explicitly positioned using x and y properties of the element. To make sure the UI remains coherent for screens of various sizes, normally these would be used together with the align property to automatically adjust elements when the screen size changes. Automatic Horizontal Layout In this layout type, the layout property and setting to the column value: layout = column , which forces all of its children to be automatically arranged horizontally in columns. The size of each child specified by its width property. You can also override it by providing a layoutWidth property, which, if set to a value greater than 1, specifies an explicit size; if set to a value less than one, it is treated as a percent of the available space (i.e. 0.25 would mean the element will be allocated 25% of the available space). Setting layoutWidth to exactly 1.0 will ensure this element fills any space remaining after computing widths for all other elements in this row. Automatic Vertical Layout With this layout, the layout property is set to row : layout = row , which forces all of the element's children to be laid out vertically using their computed height. This is useful for laying out forms, for example, where a series of controls each have their own row. You also use the marginTop property on each child to specify top margins for elements. Note that these three methods can be combined with nesting, to produce essentially any layout possible. One could have a top level element with two horizontally-spaced panes, each of which contains a series of vertically spaced items (such as a lsit of emails on the left side and a form with details on the right which reflects the information about the currently selected email). Also note that there is another option to layout elements - you could create a UIGrid element , which creates a regular grid, and place UI elements in cells to produce a regular grid layout. Debug Mode Development When running a project in the debug mode (Visual Studio/XCode), you will see two additional items on the screen. In the top-left corner, you will see a piece of text that changes between \"Active\" and \"Inactive\". When this label says \"Inactive\", it means HyperUI isn't redrawing the screen - an optimization to avoid using too much power and drain laptop and mobile device batteries. When something that requires a screen redraw happens, the screen is redrawn and the label temporarily reverts to say \"Active\". In the top-right corner, you will see a button that says \"Reload\". Pressing it will perform a hot reload of your UI and image files, and will refresh the interface with anything you've changed. The general workflow when working with UI, then, is to add the desired element in your UI configuration file (with initial guess at its position, size, and other properties), run the app, examine the result visually, edit the properties, reload the application as per above, and repeat the process until the element has a desired appearance. Please note that some changes (such as adding a brand-new element or removing a property) may not get picked up by the hot reload. In this case, please re-run the application and continue the process. When running in Python, you can enable the debugging mode as following: hyperui . enable_debugging ()","title":"Main UI Concepts"},{"location":"uiConcepts.html#specifying-ui","text":"The UI for each window is specified in a single UI specification file, such as resUI.txt. Each of these files is called a resource collection, and can be accessed through HyperUI::ResourceManager . As a note, you can also use this mechanism to load any other kind of data you need, not just UI elements. At this point, you might wonder why is there a single file instead of individual files for each UI element. This was a deliberate decision to avoid making things more complicated than they need to be (in terms of both structure and the necessary build process changes that would have been required), as well as for performance reasons, since a single file is faster to load and parse. However, you can use #include directives to break up that file into multiple files and include them into the project.","title":"Specifying UI"},{"location":"uiConcepts.html#ui-element-types","text":"Each UI element has a type, which determines its behaviour. These are described in the \"UI Elements\" section. The most basic element type is \"static\", and it can specify either a label (text) or an image - or both. Both can be controlled and offset individually. For example: elem id = elem1 text = This is a sample label image = windowBackground /elem Here, both the text and the image will be drawn at the center of the element, but can be offset: elem id = elem1 text = This is a sample label image = windowBackground textOffsetX = 20up textOffsetY = 10up imageOffsetX = -50up imageOffsetY = -25up /elem Now, the text will be shifted 20 universal pixels to the right and 10 universal pixels down, while the image will be shifted 50 universal pixels up and 25 universal pixels to the left. For more options on what else can be done with static elements, please see the Static Element documentation. Note that the image value of windowBackground refers to an entry in the graphics resource collection, not the file directly.","title":"UI Element Types"},{"location":"uiConcepts.html#layers","text":"Most UI systems show and hide UI elements directly and individually - that is, they expect you to say \"show (or hide) an element with id X\". In our system, we use layers of UI elements instead; each top-level UI element must have a layer property, which is set to any simple custom string, i.e.: layer = myCustomLayerName . A layer can then be shown using a showUI(\"myCustomLayerName\") function call. This method has several advantages: There are fewer hard-coded strings in the code, since there are fewer layer names in the code than individual element ids It is much easier to show several UI elements at the same time, especially if each of them has its own animation style, than individually showing each one using ids","title":"Layers"},{"location":"uiConcepts.html#universal-pixels","text":"All distances and sizes in HyperUI are all specified in \"universal pixels\" - abbreviated as \"up\". The reasoning behind this is that HyperUI runs on many devices with different screen densities, and we want to specify the UI only once. So, if you specify an element width of \"100up\", it will be automatically converted to 100 pixels on a non-Retina laptop display, but to 200 pixels on a Retina one. This ensures that the button remains the same size on the physical screen of the device.","title":"Universal Pixels"},{"location":"uiConcepts.html#element-positioning","text":"Our elements are positioned using the XY system with the origin in the top-left corner of the screen, similar to many other UI systems. Similarly, like other systems, each UI element has an (x,y) position and a size. However, unlike most other systems where the element position usually denotes where its top-left corner is positioned, in our system, it denotes where the center of the element is. This approach makes it much easier to nest and transform elements. By default, an element is poitioned at (0, 0), which means: If the element is a top-level element and has no parent, it is positioned in the center of the screen If the element has a parent, it is positioned at the center of the parent element You can change an element's position by modifying it's x and y properties: elem id = elem1 x = 200up y = 100up /elem It will now be offset by 200 universal pixels horizontall and 100 universal pixels vertically from its (0,0) position. In general, you can think of x and y properties as offsets from where the element would have otherwise been given all other flags on it (such as alignment).","title":"Element Positioning"},{"location":"uiConcepts.html#aligning-elements","text":"To make UI elements more adaptible and scalable, elements can be automatically aligned to its parent's element area (or the entire screen if the element is a top-level element). To do this, you can add an align property to the element. This property is an array of two elements, where the first one specifies horizontal alignment, and the second specifies vertical alignment: elem id = elem1 align = { Right, Bottom } /elem Since this is a top-level element with no parent, it will be aligned to the right-bottom corner of the screen. Note that if the element has a size, then the element's right-bottom corner will be aligned to the right-bottom corner of the screen; however, if the element has a zero size, then its center will be aligned to that screen corner. What if you want to align an element only on one axis? You can always specify __none___ as the other array element to avoid performing any alignment at all: align = { Right, __none__} What if you want to align the same element to the bottom-right corner of the screen, but also offset it a little? Well, it's easy and logical - you just specify its new position The following values are accepted for the first (horizontal) align flag: Value Meaning Left Aligns the element to the left boundary of the parent element or screen Center Aligns the element to the center of the parent element or screen, proportionately scaling the offset specified by the element's x value when the window size changes Right Aligns the element to the right boundary of the parent element or screen __none__ Does not align the element horizontally The following values are accepted for the second (vertical) align flag: Value Meaning Top Aligns the element to the top boundary of the parent element or screen Center Aligns the element to the center of the parent element or screen, proportionately scaling the offset specified by the element's y value when the window size changes Bottom Aligns the element to the bottom boundary of the parent element or screen __none__ Does not align the element vertically","title":"Aligning Elements"},{"location":"uiConcepts.html#specifying-size","text":"By default, an element has no size. This means it cannot be clicked, for example. It also means its image cannot be stretched or tiled to fill it, and all alignment will be done on its center, instead of on its actual area. Two of the most common ways of specifying the size are by setting a static size or by setting the size as a portion of its parent's size. To specify a static size, you can simply set the element's width and height property: button id = elem1 width = 200up height = 100up /button This button is now 200 universal pixels wide and 100 universal pixels tall. This, however, is an approach that works well only for a specific subset of cases. It is often the case that an element needs to resizable. In this case, we can use the following properties: elem id = elem1 fillXLess = 20up fillYLess = 10up /elem This element will be now be the same size as its parent less a padding of 20 universal pixels on each side horizontally, and 10 universal pixels on each top and bottom. This approach is often useful when dividing the screen or an element into sections that need to be resizable. These can also be mixed - that is, an element's width can be specified using the fillXLess property, but it's height can be specified using the height property - or vice versa.","title":"Specifying Size"},{"location":"uiConcepts.html#layout-types","text":"There are three main methods of laying out the user interface elements in our platform.","title":"Layout Types"},{"location":"uiConcepts.html#explicit-positioning","text":"In this method, children of an element are explicitly positioned using x and y properties of the element. To make sure the UI remains coherent for screens of various sizes, normally these would be used together with the align property to automatically adjust elements when the screen size changes.","title":"Explicit Positioning"},{"location":"uiConcepts.html#automatic-horizontal-layout","text":"In this layout type, the layout property and setting to the column value: layout = column , which forces all of its children to be automatically arranged horizontally in columns. The size of each child specified by its width property. You can also override it by providing a layoutWidth property, which, if set to a value greater than 1, specifies an explicit size; if set to a value less than one, it is treated as a percent of the available space (i.e. 0.25 would mean the element will be allocated 25% of the available space). Setting layoutWidth to exactly 1.0 will ensure this element fills any space remaining after computing widths for all other elements in this row.","title":"Automatic Horizontal Layout"},{"location":"uiConcepts.html#automatic-vertical-layout","text":"With this layout, the layout property is set to row : layout = row , which forces all of the element's children to be laid out vertically using their computed height. This is useful for laying out forms, for example, where a series of controls each have their own row. You also use the marginTop property on each child to specify top margins for elements. Note that these three methods can be combined with nesting, to produce essentially any layout possible. One could have a top level element with two horizontally-spaced panes, each of which contains a series of vertically spaced items (such as a lsit of emails on the left side and a form with details on the right which reflects the information about the currently selected email). Also note that there is another option to layout elements - you could create a UIGrid element , which creates a regular grid, and place UI elements in cells to produce a regular grid layout.","title":"Automatic Vertical Layout"},{"location":"uiConcepts.html#debug-mode-development","text":"When running a project in the debug mode (Visual Studio/XCode), you will see two additional items on the screen. In the top-left corner, you will see a piece of text that changes between \"Active\" and \"Inactive\". When this label says \"Inactive\", it means HyperUI isn't redrawing the screen - an optimization to avoid using too much power and drain laptop and mobile device batteries. When something that requires a screen redraw happens, the screen is redrawn and the label temporarily reverts to say \"Active\". In the top-right corner, you will see a button that says \"Reload\". Pressing it will perform a hot reload of your UI and image files, and will refresh the interface with anything you've changed. The general workflow when working with UI, then, is to add the desired element in your UI configuration file (with initial guess at its position, size, and other properties), run the app, examine the result visually, edit the properties, reload the application as per above, and repeat the process until the element has a desired appearance. Please note that some changes (such as adding a brand-new element or removing a property) may not get picked up by the hot reload. In this case, please re-run the application and continue the process. When running in Python, you can enable the debugging mode as following: hyperui . enable_debugging ()","title":"Debug Mode Development"}]}